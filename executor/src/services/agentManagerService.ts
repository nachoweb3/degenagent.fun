import { Connection, PublicKey, Transaction, SystemProgram, TransactionInstruction } from '@solana/web3.js';
import * as anchor from '@coral-xyz/anchor';

const MANAGER_PROGRAM_ID = new PublicKey(
  process.env.MANAGER_PROGRAM_ID || 'Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS'
);

const TREASURY_WALLET = new PublicKey(
  process.env.TREASURY_WALLET || 'TReasuryWa11et1111111111111111111111111111'
);

/**
 * Build an execute_trade instruction for the agent-manager program
 * This will calculate and transfer the 1% platform fee to treasury
 */
export async function buildExecuteTradeInstruction(
  connection: Connection,
  agentStatePubkey: PublicKey,
  agentWalletPubkey: PublicKey,
  fromMint: PublicKey,
  toMint: PublicKey,
  amountIn: number,
  minOutput: number,
  actualOutput: number
): Promise<TransactionInstruction> {
  // Find vault PDA
  const [vault] = PublicKey.findProgramAddressSync(
    [Buffer.from('vault'), agentStatePubkey.toBuffer()],
    MANAGER_PROGRAM_ID
  );

  // Find agent state PDA to get the bump
  const agentStateAccount = await connection.getAccountInfo(agentStatePubkey);

  if (!agentStateAccount) {
    throw new Error('Agent state account not found');
  }

  // Build instruction data
  // Format: [instruction_discriminator(8), from_mint(32), to_mint(32), amount(8), min_output(8), actual_output(8)]
  const instructionData = Buffer.alloc(8 + 32 + 32 + 8 + 8 + 8);

  // Instruction discriminator for execute_trade (would be generated by Anchor)
  // For MVP, we'll use a placeholder. In production, this comes from the IDL
  const discriminator = Buffer.from([0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90]);
  discriminator.copy(instructionData, 0);

  // from_mint
  fromMint.toBuffer().copy(instructionData, 8);

  // to_mint
  toMint.toBuffer().copy(instructionData, 40);

  // amount (u64 little-endian)
  instructionData.writeBigUInt64LE(BigInt(amountIn), 72);

  // min_output (u64 little-endian)
  instructionData.writeBigUInt64LE(BigInt(minOutput), 80);

  // actual_output (u64 little-endian)
  instructionData.writeBigUInt64LE(BigInt(actualOutput), 88);

  // Build accounts array
  const keys = [
    { pubkey: agentStatePubkey, isSigner: false, isWritable: true },
    { pubkey: vault, isSigner: false, isWritable: true },
    { pubkey: TREASURY_WALLET, isSigner: false, isWritable: true },
    { pubkey: agentWalletPubkey, isSigner: true, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
  ];

  return new TransactionInstruction({
    keys,
    programId: MANAGER_PROGRAM_ID,
    data: instructionData,
  });
}

/**
 * Calculate expected platform fee from profit
 */
export function calculatePlatformFee(amountIn: number, actualOutput: number): number {
  if (actualOutput <= amountIn) {
    return 0; // No profit, no fee
  }

  const profit = actualOutput - amountIn;
  const platformFee = Math.floor(profit / 100); // 1% of profit

  return platformFee;
}

/**
 * Get revenue stats for an agent
 */
export async function getAgentRevenueStats(
  connection: Connection,
  agentStatePubkey: PublicKey
): Promise<{
  totalTrades: number;
  totalVolume: number;
  revenuePool: number;
  platformFeesCollected: number;
}> {
  try {
    const accountInfo = await connection.getAccountInfo(agentStatePubkey);

    if (!accountInfo) {
      throw new Error('Agent not found');
    }

    // For MVP, decode the account data manually
    // In production, use Anchor's account decoder with the IDL

    // Mock data structure based on AgentState
    // In production, this would be properly decoded
    return {
      totalTrades: 0,
      totalVolume: 0,
      revenuePool: 0,
      platformFeesCollected: 0
    };

  } catch (error) {
    console.error('Error getting agent revenue stats:', error);
    throw error;
  }
}
